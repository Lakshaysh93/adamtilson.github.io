<!DOCTYPE html>
<!-- Top Navigation modified from CodingNepal - https://www.codingnepalweb.com/mega-menu-and-dropdown-menu-html-css/ -->
<!-- Side navigation modified from Sticky, Smooth, Active Nav by Chris Coyier https://codepen.io/chriscoyier/pen/qyELzd -->
<!-- Collabsibles from W3Schools https://www.w3schools.com/howto/howto_js_collapsible.asp -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> ENSE 411 Lab 4 </title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/> 
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <link rel="icon" type="image/svg+xml" href="/assets/svg/at.svg">
  <!-- for mathjax support -->

</head>
<body>
  <nav id="site">
    <div class="wrapper">
      <div class="logo"><a href="#"><img
        src="/assets/svg/at.svg" alt="logo" height="35" width="35" /></a></div>
      <input type="radio" name="slider" id="menu-btn">
      <input type="radio" name="slider" id="close-btn">
      <ul class="nav-links">
        <label for="close-btn" class="btn close-btn"><i class="fas fa-times"></i></label>
        <li><a href="#">Blog</a></li>
        <li>
          <a href="#" class="desktop-item">CV â–¾</a>
          <input type="checkbox" id="showDrop">
          <label for="showDrop" class="mobile-item">CV â–¾</label>
          <ul class="drop-menu">
            <li><a href="#">Technical</a></li>
            <li><a href="#">Academic</a></li>
          </ul>
        </li>
        <li>
          <a href="#" class="desktop-item">Laboratory â–¾</a>
          <input type="checkbox" id="showMega">
          <label for="showMega" class="mobile-item">Laboratory â–¾</label>
          <div class="mega-box">
            <div class="content">


              <div class="row">
                <header>ENSE 271</header>
                <ul class="mega-links">
                  <li><a href="/labs/ense-271/">Schedule</a></li>
                  <li><a href="/labs/ense-271/lab-1">Lab 1</a></li>
                  <li><a href="/labs/ense-271/lab-2">Lab 2</a></li>
                  <li><a href="/labs/ense-271/lab-3">Lab 3</a></li>
                  <li><a href="/labs/ense-271/lab-4">Lab 4</a></li>
                  <li><a href="/labs/ense-271/lab-5">Lab 5</a></li>
                  <li><a href="/labs/ense-271/lab-6">Lab 6</a></li>
                  <!-- <li><a href="/labs/ense-271/lab-7">Lab 7</a></li> -->
                </ul>
              </div>

              <!-- <div class="row">
                <header>ENSE 374</header>
                <ul class="mega-links">
                  <li><a href="/labs/ense-374/">Schedule</a></li>
                  <li><a href="/labs/ense-374/lab-1">Lab 1</a></li>
                  <li><a href="/labs/ense-374/lab-2">Lab 2</a></li>
                  <li><a href="/labs/ense-374/lab-3">Lab 3</a></li>
                  <li><a href="/labs/ense-374/lab-4">Lab 4</a></li>
                  <li><a href="/labs/ense-374/lab-5">Lab 5</a></li>
                  <li><a href="/labs/ense-374/lab-6">Lab 6</a></li>
                  <li><a href="/labs/ense-374/lab-7">Lab 7</a></li>
                  <li><a href="/labs/ense-374/lab-8">Lab 8</a></li>
                  <li><a href="/labs/ense-374/lab-9">Lab 9</a></li>
                </ul>
              </div> -->

              <!-- <div class="row">
                <header>ENSE 411</header>
                <ul class="mega-links">
                  <li><a href="/labs/ense-411/schedule">Schedule</a></li>
                  <li><a href="/labs/ense-411/lab-0">Lab 0</a></li>
                  <li><a href="/labs/ense-411/lab-1">Lab 1</a></li>
                  <li><a href="/labs/ense-411/lab-2">Lab 2</a></li>
                  <li><a href="/labs/ense-411/lab-3">Lab 3</a></li>
                  <li><a href="/labs/ense-411/lab-4">Lab 4</a></li>
                  <li><a href="/labs/ense-411/lab-5">Lab 5</a></li>
                </ul>
              </div> -->

              <!-- <div class="row">
                <header>ENSE 472</header>
                <ul class="mega-links">
                  <li><a href="/labs/ense-472/">Schedule</a></li>
                  <li><a href="/labs/ense-472/lab-1">Lab 1</a></li>
                  <li><a href="/labs/ense-472/lab-2">Lab 2</a></li>
                  <li><a href="/labs/ense-472/lab-3">Lab 3</a></li>
                  <li><a href="/labs/ense-472/lab-4">Lab 4</a></li>
                  <li><a href="/labs/ense-472/lab-5">Lab 5</a></li>
                </ul>
              </div> -->
            </div>
          </div>
        </li>
        <li><a href="javascript:void(0);" id="darklink">ðŸŒžï¸Ž</a></li>
      </ul>
      <label for="menu-btn" class="btn menu-btn"><i class="fas fa-bars"></i></label>
    </div>
  </nav>
  
  <div class="body">
    <nav id="toc-nav">
      <ul id="toc">

      </ul>
    </nav>

    <main id="content" class="main-content" role="main">
        <p></p>
        <h1 id="lab-4-ghostbusters">Lab 4: Ghostbusters</h1>

<p>ENSE 411 - Artificial Intelligence - Laboratory</p>

<p>University of Regina - Engineering and Applied Science - Software Systems Engineering</p>

<p>Lab Instructor: <a href="mailto:Adam.Tilson@uregina.ca">Adam Tilson</a></p>

<hr />

<p><button class="expandall">Collapse All</button></p>
<section id="introduction"><button class="collapsible">Introduction</button><div class="text-content"><div class="text-inner">

      <p><img src="res/haiku.png" alt="" /></p>

      <p>I can hear you, ghost.</p>

      <p>Running wonâ€™t save you from my</p>

      <p>Particle filter!</p>

      <p>Pacman spends his life running from ghosts, but things were not always so. Legend has it that many years ago, Pacmanâ€™s great grandfather Grandpac learned to hunt ghosts for sport. However, he was blinded by his power and could only track ghosts by their banging and clanging.</p>

      <p>In this lab, you will design Pacman agents that use sensors to locate and eat invisible ghosts. Youâ€™ll advance from locating single, stationary ghosts to hunting packs of multiple moving ghosts with ruthless efficiency.</p>

      <p>The code for this lab contains the following files, available as a zip archive <code class="language-plaintext highlighter-rouge">lab-4-tracking.zip</code>.</p>

      <p>Files youâ€™ll edit:</p>

      <table>
        <thead>
          <tr>
            <th>file</th>
            <th>purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">bustersAgents.py</code></td>
            <td>Agents for playing the Ghostbusters variant of Pacman.</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">inference.py</code></td>
            <td>Code for tracking ghosts over time using their sounds.</td>
          </tr>
        </tbody>
      </table>

      <p>Files you will not edit:</p>

      <table>
        <thead>
          <tr>
            <th>file</th>
            <th>purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">busters.py</code></td>
            <td>The main entry to Ghostbusters (replacing Pacman.py)</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">bustersGhostAgents.py</code></td>
            <td>New ghost agents for Ghostbusters</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">distanceCalculator.py</code></td>
            <td>Computes maze distances</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">game.py</code></td>
            <td>Inner workings and helper classes for Pacman</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">ghostAgents.py</code></td>
            <td>Agents to control ghosts</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">graphicsDisplay.py</code></td>
            <td>Graphics for Pacman</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">graphicsUtils.py</code></td>
            <td>Support for Pacman graphics</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">keyboardAgents.py</code></td>
            <td>Keyboard interfaces to control Pacman</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">layout.py</code></td>
            <td>Code for reading layout files and storing their contents</td>
          </tr>
          <tr>
            <td><code class="language-plaintext highlighter-rouge">util.py</code></td>
            <td>Utility functions</td>
          </tr>
        </tbody>
      </table>

      <p><strong>Files to Edit and Submit:</strong> You will fill in portions of <code class="language-plaintext highlighter-rouge">bustersAgents.py</code> and <code class="language-plaintext highlighter-rouge">inference.py</code> during the assignment. You should submit these files with your code and comments. Please do not change the other files in this distribution or submit any of our original files other than these files.</p>

      <p><strong>Evaluation:</strong> Your code will be autograded for technical correctness. Please <em>do not</em> change the names of any provided functions or classes within the code, or you will wreak havoc on the autograder. However, the correctness of your implementation â€“ not the autograderâ€™s judgements â€“ will be the final judge of your score. If necessary, we will review and grade assignments individually to ensure that you receive due credit for your work.</p>

      <p><strong>Academic Dishonesty:</strong> We will be checking your code against other submissions in the class for logical redundancy. If you copy someone elseâ€™s code and submit it with minor changes, we will know. These cheat detectors are quite hard to fool, so please donâ€™t try. We trust you all to submit your own work only; please donâ€™t let us down. If you do, we will pursue the strongest consequences available to us.</p>

    </div></div></section>
<section id="ghostbustersandbns"><button class="collapsible">Ghostbusters and BNs</button><div class="text-content"><div class="text-inner">

      <p>In the ENSE411 version of Ghostbusters, the goal is to hunt down scared but invisible ghosts. Pacman, ever resourceful, is equipped with sonar (ears) that provides noisy readings of the Manhattan distance to each ghost. The game ends when Pacman has eaten all the ghosts. To start, try playing a game yourself using the keyboard.</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python busters.py
</code></pre></div>      </div>

      <p>The blocks of color indicate where the each ghost could possibly be, given the noisy distance readings provided to Pacman. The noisy distances at the bottom of the display are always non-negative, and always within 7 of the true distance. The probability of a distance reading decreases exponentially with its difference from the true distance.</p>

      <p>Your primary task in this lab is to implement inference to track the ghosts. For the keyboard based game above, a crude form of inference was implemented for you by default: all squares in which a ghost could possibly be are shaded by the color of the ghost. Naturally, we want a better estimate of the ghostâ€™s position. Fortunately, Bayesâ€™ Nets provide us with powerful tools for making the most of the information we have. Throughout the rest of this Lab, you will implement algorithms for performing both exact and approximate inference using Bayesâ€™ Nets. The lab is challenging, so we do encourage you to start early and seek help when necessary.</p>

      <p>While watching and debugging your code with the autograder, it will be helpful to have some understanding of what the autograder is doing. There are 2 types of tests in this Lab, as differentiated by their <code class="language-plaintext highlighter-rouge">*.test</code> files found in the subdirectories of the <code class="language-plaintext highlighter-rouge">test_cases</code> folder. For tests of class <code class="language-plaintext highlighter-rouge">DoubleInferenceAgentTest</code>, your will see visualizations of the inference distributions generated by your code, but all Pacman actions will be preselected according to the actions of the staff implementation. This is necessary in order to allow comparison of your distributions with the staffâ€™s distributions. The second type of test is <code class="language-plaintext highlighter-rouge">GameScoreTest</code>, in which your <code class="language-plaintext highlighter-rouge">BustersAgent</code> will actually select actions for Pacman and you will watch your Pacman play and win games.</p>

      <p>As you implement and debug your code, you may find it useful to run a single test at a time. In order to do this you will need to use the <code class="language-plaintext highlighter-rouge">-t</code> flag with the autograder. For example if you only want to run the first test of question 1, use:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -t test_cases/q1/1-ExactObserve
</code></pre></div>      </div>

      <p>In general, all test cases can be found inside <code class="language-plaintext highlighter-rouge">test_cases/q*</code>.</p>

    </div></div></section>
<section id="q0"><button class="collapsible">Q0</button><div class="text-content"><div class="text-inner">
      <h3 id="discretedistribution-class-0-points">DiscreteDistribution Class (0 points)</h3>

      <p>Throughout this project, we will be using the <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> class defined in <code class="language-plaintext highlighter-rouge">inference.py</code> to model belief distributions and weight distributions. This class is an extension of the built-in Python dictionary class, where the keys are the different discrete elements of our distribution, and the corresponding values are proportional to the belief or weight that the distribution assigns that element. This question asks you to fill in the missing parts of this class, which will be crucial for later questions (even though this question itself is worth no points).</p>

      <p>First, fill in the <code class="language-plaintext highlighter-rouge">normalize</code> method, which normalizes the values in the distribution to sum to one, but keeps the proportions of the values the same. Use the <code class="language-plaintext highlighter-rouge">total</code> method to find the sum of the values in the distribution. For an empty distribution or a distribution where all of the values are zero, do nothing. Note that this method modifies the distribution directly, rather than returning a new distribution.</p>

      <p>Second, fill in the <code class="language-plaintext highlighter-rouge">sample</code> method, which draws a sample from the distribution, where the probability that a key is sampled is proportional to its corresponding value. Assume that the distribution is not empty, and not all of the values are zero. Note that the distribution does not necessarily have to be normalized prior to calling this method. You may find Pythonâ€™s built-in <code class="language-plaintext highlighter-rouge">random.random()</code> function useful for this question.</p>

      <p>There are no autograder tests for this question, but the correctness of your implementation can be easily checked. We have provided Python doctests as a starting point, and you can feel free to add more and implement other tests of your own. You can run the doctests using:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m doctest -v inference.py
</code></pre></div>      </div>

      <p>Note that, depending on the implementation details of the <code class="language-plaintext highlighter-rouge">sample</code> method, some correct implementations may not pass the doctests that are provided. To thoroughly check the correctness of your <code class="language-plaintext highlighter-rouge">sample</code> method, you should instead draw many samples and see if the frequency of each key converges to be proportional of its corresponding value.</p>

    </div></div></section>
<section id="q1"><button class="collapsible">Q1</button><div class="text-content"><div class="text-inner">
      <h3 id="observation-probability-2-points">Observation Probability (2 points)</h3>

      <p>In this question, you will implement the <code class="language-plaintext highlighter-rouge">getObservationProb</code> method in the <code class="language-plaintext highlighter-rouge">InferenceModule</code> base class in <code class="language-plaintext highlighter-rouge">inference.py</code>. This method takes in an observation (which is a noisy reading of the distance to the ghost), Pacmanâ€™s position, the ghostâ€™s position, and the position of the ghostâ€™s jail, and returns the probability of the noisy distance reading given Pacmanâ€™s position and the ghostâ€™s position. In other words, we want to return <code class="language-plaintext highlighter-rouge">P(noisyDistance | pacmanPosition, ghostPosition)</code>.</p>

      <p>The distance sensor has a probability distribution over distance readings given the true distance from Pacman to the ghost. This distribution is modeled by the function <code class="language-plaintext highlighter-rouge">busters.getObservationProbability(noisyDistance, trueDistance)</code>, which returns <code class="language-plaintext highlighter-rouge">P(noisyDistance | trueDistance)</code> and is provided for you. You should use this function to help you solve the problem, and use the provided <code class="language-plaintext highlighter-rouge">manhattanDistance</code> function to find the distance between Pacmanâ€™s location and the ghostâ€™s location.</p>

      <p>However, there is the special case of jail that we have to handle as well. Specifically, when we capture a ghost and send it to the jail location, our distance sensor deterministically returns <code class="language-plaintext highlighter-rouge">None</code>, and nothing else. So, if the ghostâ€™s position is the jail position, then the observation is <code class="language-plaintext highlighter-rouge">None</code> with probability 1, and everything else with probability 0. Conversely, if the distance reading is not <code class="language-plaintext highlighter-rouge">None</code>, then the ghost is in jail with probability 0. If the distance reading is <code class="language-plaintext highlighter-rouge">None</code> then the ghost is in jail with probability 1. Make sure you handle this special case in your implementation.</p>

      <p>To test your code and run the autograder for this question:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q1
</code></pre></div>      </div>

      <p>As a general note, it is possible for some of the autograder tests to take a long time to run for this project, and you will have to exercise patience. As long as the autograder doesnâ€™t time out, you should be fine (provided that you actually pass the tests).</p>

    </div></div></section>
<section id="q2"><button class="collapsible">Q2</button><div class="text-content"><div class="text-inner">
      <h3 id="exact-inference-observation-3-points">Exact Inference Observation (3 points)</h3>

      <p>In this question, you will implement the <code class="language-plaintext highlighter-rouge">observeUpdate</code> method in <code class="language-plaintext highlighter-rouge">ExactInference</code> class of <code class="language-plaintext highlighter-rouge">inference.py</code> to correctly update the agentâ€™s belief distribution over ghost positions given an observation from Pacmanâ€™s sensors. You are implementing the online belief update for observing new evidence. The <code class="language-plaintext highlighter-rouge">observeUpdate</code> method should, for this problem, update the belief at every position on the map after receiving a sensor reading. You should iterate your updates over the variable <code class="language-plaintext highlighter-rouge">self.allPositions</code> which includes all legal positions plus the special jail position. Beliefs represent the probability that the ghost is at a particular location, and are stored as a <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> object in a field called <code class="language-plaintext highlighter-rouge">self.beliefs</code>, which you should update.</p>

      <p>Before typing any code, write down the equation of the inference problem you are trying to solve. You should use the function <code class="language-plaintext highlighter-rouge">self.getObservationProb</code> that you wrote in the last question, which returns the probability of an observation given Pacmanâ€™s position, a potential ghost position, and the jail position. You can obtain Pacmanâ€™s position using <code class="language-plaintext highlighter-rouge">gameState.getPacmanPosition()</code>, and the jail position using <code class="language-plaintext highlighter-rouge">self.getJailPosition()</code>.</p>

      <p>In the Pacman display, high posterior beliefs are represented by bright colors, while low beliefs are represented by dim colors. You should start with a large cloud of belief that shrinks over time as more evidence accumulates. As you watch the test cases, be sure that you understand how the squares converge to their final coloring.</p>

      <p><em>Note:</em> your busters agents have a separate inference module for each ghost they are tracking. Thatâ€™s why if you print an observation inside the <code class="language-plaintext highlighter-rouge">observeUpdate</code> function, youâ€™ll only see a single number even though there may be multiple ghosts on the board.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q2
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q2 --no-graphics
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q3"><button class="collapsible">Q3</button><div class="text-content"><div class="text-inner">
      <h3 id="exact-inference-with-time-elapse-3-points">Exact Inference with Time Elapse (3 points)</h3>

      <p>In the previous question you implemented belief updates for Pacman based on his observations. Fortunately, Pacmanâ€™s observations are not his only source of knowledge about where a ghost may be. Pacman also has knowledge about the ways that a ghost may move; namely that the ghost can not move through a wall or more than one space in one time step.</p>

      <p>To understand why this is useful to Pacman, consider the following scenario in which there is Pacman and one Ghost. Pacman receives many observations which indicate the ghost is very near, but then one which indicates the ghost is very far. The reading indicating the ghost is very far is likely to be the result of a buggy sensor. Pacmanâ€™s prior knowledge of how the ghost may move will decrease the impact of this reading since Pacman knows the ghost could not move so far in only one move.</p>

      <p>In this question, you will implement the <code class="language-plaintext highlighter-rouge">elapseTime</code> method in <code class="language-plaintext highlighter-rouge">ExactInference</code>. The <code class="language-plaintext highlighter-rouge">elapseTime</code> step should, for this problem, update the belief at every position on the map after one time step elapsing. Your agent has access to the action distribution for the ghost through <code class="language-plaintext highlighter-rouge">self.getPositionDistribution</code>. In order to obtain the distribution over new positions for the ghost, given its previous position, use this line of code:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newPosDist = self.getPositionDistribution(gameState, oldPos)
</code></pre></div>      </div>

      <p>Where <code class="language-plaintext highlighter-rouge">oldPos</code> refers to the previous ghost position. <code class="language-plaintext highlighter-rouge">newPosDist</code> is a <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> object, where for each position <code class="language-plaintext highlighter-rouge">p</code> in <code class="language-plaintext highlighter-rouge">self.allPositions</code>, <code class="language-plaintext highlighter-rouge">newPosDist[p]</code> is the probability that the ghost is at position <code class="language-plaintext highlighter-rouge">p</code> at time <code class="language-plaintext highlighter-rouge">t + 1</code>, given that the ghost is at position <code class="language-plaintext highlighter-rouge">oldPos</code> at time <code class="language-plaintext highlighter-rouge">t</code>. Note that this call can be fairly expensive, so if your code is timing out, one thing to think about is whether or not you can reduce the number of calls to <code class="language-plaintext highlighter-rouge">self.getPositionDistribution</code>.</p>

      <p>Before typing any code, write down the equation of the inference problem you are trying to solve. In order to test your predict implementation separately from your update implementation in the previous question, this question will not make use of your update implementation.</p>

      <p>Since Pacman is not observing the ghost, this means the ghostâ€™s actions will not impact Pacmanâ€™s beliefs. Over time, Pacmanâ€™s beliefs will come to reflect places on the board where he believes ghosts are most likely to be given the geometry of the board and what Pacman already knows about their valid movements.</p>

      <p>For the tests in this question we will sometimes use a ghost with random movements and other times we will use the <code class="language-plaintext highlighter-rouge">GoSouthGhost</code>. This ghost tends to move south so over time, and without any observations, Pacmanâ€™s belief distribution should begin to focus around the bottom of the board. To see which ghost is used for each test case you can look in the <code class="language-plaintext highlighter-rouge">.test</code> files.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q3
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q3 --no-graphics
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

      <p>As you watch the autograder output, remember that lighter squares indicate that pacman believes a ghost is more likely to occupy that location, and darker squares indicate a ghost is less likely to occupy that location. For which of the test cases do you notice differences emerging in the shading of the squares? Can you explain why some squares get lighter and some squares get darker?</p>

    </div></div></section>
<section id="q4"><button class="collapsible">Q4: </button><div class="text-content"><div class="text-inner">
      <h3 id="exact-inference-full-test-2-points">Exact Inference Full Test (2 points)</h3>

      <p>Now that Pacman knows how to use both his prior knowledge and his observations when figuring out where a ghost is, he is ready to hunt down ghosts on his own. This question will use your <code class="language-plaintext highlighter-rouge">observeUpdate</code> and <code class="language-plaintext highlighter-rouge">elapseTime</code> implementations together, along with a simple greedy hunting strategy which you will implement for this question. In the simple greedy strategy, Pacman assumes that each ghost is in its most likely position according to his beliefs, then moves toward the closest ghost. Up to this point, Pacman has moved by randomly selecting a valid action.</p>

      <p>Implement the <code class="language-plaintext highlighter-rouge">chooseAction</code> method in <code class="language-plaintext highlighter-rouge">GreedyBustersAgent</code> in <code class="language-plaintext highlighter-rouge">bustersAgents.py</code>. Your agent should first find the most likely position of each remaining uncaptured ghost, then choose an action that minimizes the maze distance to the closest ghost.</p>

      <p>To find the maze distance between any two positions <code class="language-plaintext highlighter-rouge">pos1</code> and <code class="language-plaintext highlighter-rouge">pos2</code>, use <code class="language-plaintext highlighter-rouge">self.distancer.getDistance(pos1, pos2)</code>. To find the successor position of a position after an action:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>successorPosition = Actions.getSuccessor(position, action)
</code></pre></div>      </div>

      <p>You are provided with <code class="language-plaintext highlighter-rouge">livingGhostPositionDistributions</code>, a list of <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> objects representing the position belief distributions for each of the ghosts that are still uncaptured.</p>

      <p>If correctly implemented, your agent should win the game in <code class="language-plaintext highlighter-rouge">q4/3-gameScoreTest</code> with a score greater than 700 at least 8 out of 10 times. Note: the autograder will also check the correctness of your inference directly, but the outcome of games is a reasonable sanity check.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q4
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q4 --no-graphics`
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q5"><button class="collapsible">Q5</button><div class="text-content"><div class="text-inner">
      <h3 id="approximate-inference-initialization-and-beliefs-2-points">Approximate Inference Initialization and Beliefs (2 points)</h3>

      <p>Approximate inference is very trendy among ghost hunters this season. For the next few questions, you will implement a particle filtering algorithm for tracking a single ghost.</p>

      <p>First, implement the functions <code class="language-plaintext highlighter-rouge">initializeUniformly</code> and <code class="language-plaintext highlighter-rouge">getBeliefDistribution</code> in the <code class="language-plaintext highlighter-rouge">ParticleFilter</code> class in <code class="language-plaintext highlighter-rouge">inference.py</code>. A particle (sample) is a ghost position in this inference problem. Note that, for initialization, particles should be evenly (not randomly) distributed across legal positions in order to ensure a uniform prior.</p>

      <p>Note that the variable you store your particles in must be a list. A list is simply a collection of unweighted variables (positions in this case). Storing your particles as any other data type, such as a dictionary, is incorrect and will produce errors. The <code class="language-plaintext highlighter-rouge">getBeliefDistribution</code> method then takes the list of particles and converts it into a <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> object.</p>

      <p>To test your code and run the autograder for this question:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q5
</code></pre></div>      </div>

    </div></div></section>
<section id="q6"><button class="collapsible">Q6</button><div class="text-content"><div class="text-inner">
      <h3 id="approximate-inference-observation-3-points">Approximate Inference Observation (3 points)</h3>

      <p>Next, we will implement the <code class="language-plaintext highlighter-rouge">observeUpdate</code> method in the <code class="language-plaintext highlighter-rouge">ParticleFilter</code> class in <code class="language-plaintext highlighter-rouge">inference.py</code>. This method constructs a weight distribution over <code class="language-plaintext highlighter-rouge">self.particles</code> where the weight of a particle is the probability of the observation given Pacmanâ€™s position and that particle location. Then, we resample from this weighted distribution to construct our new list of particles.</p>

      <p>You should again use the function <code class="language-plaintext highlighter-rouge">self.getObservationProb</code> to find the probability of an observation given Pacmanâ€™s position, a potential ghost position, and the jail position. The sample method of the <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> class will also be useful. As a reminder, you can obtain Pacmanâ€™s position using <code class="language-plaintext highlighter-rouge">gameState.getPacmanPosition()</code>, and the jail position using <code class="language-plaintext highlighter-rouge">self.getJailPosition()</code>.</p>

      <p>There is one special case that a correct implementation must handle. When all particles receive zero weight, the list of particles should be reinitialized by calling initializeUniformly. The total method of the DiscreteDistribution may be useful.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q6

</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q6 --no-graphics
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q7"><button class="collapsible">Q7</button><div class="text-content"><div class="text-inner">
      <h3 id="approximate-inference-with-time-elapse-3-points">Approximate Inference with Time Elapse (3 points)</h3>

      <p>Implement the <code class="language-plaintext highlighter-rouge">elapseTime</code> function in the <code class="language-plaintext highlighter-rouge">ParticleFilter</code> class in <code class="language-plaintext highlighter-rouge">inference.py</code>. This function should construct a new list of particles that corresponds to each existing particle in <code class="language-plaintext highlighter-rouge">self.particles</code> advancing a time step, and then assign this new list back to <code class="language-plaintext highlighter-rouge">self.particles</code>. When complete, you should be able to track ghosts nearly as effectively as with exact inference.</p>

      <p>Note that in this question, we will test both the <code class="language-plaintext highlighter-rouge">elapseTime</code> function in isolation, as well as the full implementation of the particle filter combining <code class="language-plaintext highlighter-rouge">elapseTime</code> and <code class="language-plaintext highlighter-rouge">observe</code>.</p>

      <p>As in the <code class="language-plaintext highlighter-rouge">elapseTime</code> method of the <code class="language-plaintext highlighter-rouge">ExactInference</code> class, you should use:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newPosDist = self.getPositionDistribution(gameState, oldPos)
</code></pre></div>      </div>

      <p>This line of code obtains the distribution over new positions for the ghost, given its previous position (<code class="language-plaintext highlighter-rouge">oldPos</code>). The sample method of the <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> class will also be useful.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q7
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q7 --no-graphics
</code></pre></div>      </div>

      <p>Note that even with no graphics, this test may take several minutes to run.</p>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q8"><button class="collapsible">Q8</button><div class="text-content"><div class="text-inner">
      <h3 id="joint-particle-filter-observation-1-points">Joint Particle Filter Observation (1 points)</h3>

      <p>So far, we have tracked each ghost independently, which works fine for the default <code class="language-plaintext highlighter-rouge">RandomGhost</code> or more advanced <code class="language-plaintext highlighter-rouge">DirectionalGhost</code>. However, the prized <code class="language-plaintext highlighter-rouge">DispersingGhost</code> chooses actions that avoid other ghosts. Since the ghostsâ€™ transition models are no longer independent, all ghosts must be tracked jointly in a dynamic Bayes net!</p>

      <p>The Bayes net has the following structure, where the hidden variables G represent ghost positions and the emission variables E are the noisy distances to each ghost. This structure can be extended to more ghosts, but only two (a and b) are shown below.</p>

      <p><img src="res/dbn.png" alt="" /></p>

      <p>You will now implement a particle filter that tracks multiple ghosts simultaneously. Each particle will represent a tuple of ghost positions that is a sample of where all the ghosts are at the present time. The code is already set up to extract marginal distributions about each ghost from the joint inference algorithm you will create, so that belief clouds about individual ghosts can be displayed.</p>

      <p>Complete the <code class="language-plaintext highlighter-rouge">initializeUniformly</code> method in <code class="language-plaintext highlighter-rouge">JointParticleFilter</code> in <code class="language-plaintext highlighter-rouge">inference.py</code>. Your initialization should be consistent with a uniform prior. You may find the Python <code class="language-plaintext highlighter-rouge">itertools</code> package helpful. Specifically, look at <code class="language-plaintext highlighter-rouge">itertools.product</code> to get an implementation of the Cartesian product. However, note that, if you use this, the permutations are not returned in a random order. Therefore, you must then shuffle the list of permutations in order to ensure even placement of particles across the board.</p>

      <p>As before, use <code class="language-plaintext highlighter-rouge">self.legalPositions</code> to obtain a list of positions a ghost may occupy. Also as before, the variable you store your particles in must be a list.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q8
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q8 --no-graphics
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q9"><button class="collapsible">Q9</button><div class="text-content"><div class="text-inner">
      <h3 id="joint-particle-filter-observation-3-points">Joint Particle Filter Observation (3 points)</h3>

      <p>In this question, you will complete the <code class="language-plaintext highlighter-rouge">observeUpdate</code> method in the <code class="language-plaintext highlighter-rouge">JointParticleFilter</code> class of <code class="language-plaintext highlighter-rouge">inference.py</code>. A correct implementation will weight and resample the entire list of particles based on the observation of all ghost distances.
To loop over all the ghosts, use:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in range(self.numGhosts):
    ...
</code></pre></div>      </div>

      <p>You can still obtain Pacmanâ€™s position using <code class="language-plaintext highlighter-rouge">gameState.getPacmanPosition()</code>, but to get the jail position for a ghost, use <code class="language-plaintext highlighter-rouge">self.getJailPosition(i)</code>, since now there are multiple ghosts each with their own jail positions.</p>

      <p><strong>Your implementation should also again handle the special case when all particles receive zero weight.</strong> In this case, <code class="language-plaintext highlighter-rouge">self.particles</code> should be recreated from the prior distribution by calling <code class="language-plaintext highlighter-rouge">initializeUniformly</code>.</p>

      <p>As in the update method for the <code class="language-plaintext highlighter-rouge">ParticleFilter</code> class, you should again use the function <code class="language-plaintext highlighter-rouge">self.getObservationProb</code> to find the probability of an observation given Pacmanâ€™s position, a potential ghost position, and the jail position. The sample method of the <code class="language-plaintext highlighter-rouge">DiscreteDistribution</code> class will also be useful.</p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q9
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q9 --no-graphics
</code></pre></div>      </div>

      <p><strong>IMPORTANT</strong>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

    </div></div></section>
<section id="q10"><button class="collapsible">Q10</button><div class="text-content"><div class="text-inner">
      <h3 id="joint-particle-filter-time-elapse-and-full-test-3-points">Joint Particle Filter Time Elapse and Full Test (3 points)</h3>

      <p>Complete the <code class="language-plaintext highlighter-rouge">elapseTime</code> method in <code class="language-plaintext highlighter-rouge">JointParticleFilter</code> in <code class="language-plaintext highlighter-rouge">inference.py</code> to resample each particle correctly for the Bayes net. In particular, each ghost should draw a new position conditioned on the positions of all the ghosts at the previous time step.</p>

      <p>As in the last question, you can loop over the ghosts using:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in range(self.numGhosts):
    ...
</code></pre></div>      </div>

      <p>Then, assuming that <code class="language-plaintext highlighter-rouge">i</code> refers to the index of the ghost, to obtain the distributions over new positions for that single ghost, given the list (<code class="language-plaintext highlighter-rouge">prevGhostPositions</code>) of previous positions of all of the ghosts, use:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newPosDist = self.getPositionDistribution(gameState, prevGhostPositions, i, self.ghostAgents[i])
</code></pre></div>      </div>

      <p>Note that completing this question involves grading both question 9 and question 10. Since these questions involve joint distributions, they require more computational power (and time) to grade, so please be patient!</p>

      <p>As you run the autograder note that <code class="language-plaintext highlighter-rouge">q10/1-JointParticlePredict</code> and <code class="language-plaintext highlighter-rouge">q10/2-JointParticlePredict</code> test your <code class="language-plaintext highlighter-rouge">predict</code> implementations only, and <code class="language-plaintext highlighter-rouge">q10/3-JointParticleFull</code> tests both your <code class="language-plaintext highlighter-rouge">predict</code> and <code class="language-plaintext highlighter-rouge">update</code> implementations. Notice the difference between test 1 and test 3. In both tests, pacman knows that the ghosts will move to the sides of the gameboard. What is different between the tests, and why?</p>

      <p><img src="res/jpf.png" alt="" /></p>

      <p>To run the autograder for this question and visualize the output:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q10
</code></pre></div>      </div>

      <p>If you want to run this test (or any of the other tests) without graphics you can add the following flag:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q10 --no-graphics
</code></pre></div>      </div>

      <p><em>IMPORTANT</em>: In general, it is possible sometimes for the autograder to time out if running the tests with graphics. To accurately determine whether or not your code is efficient enough, you should run the tests with the <code class="language-plaintext highlighter-rouge">--no-graphics</code> flag. If the autograder passes with this flag, then you will receive full points, even if the autograder times out with graphics.</p>

      <p>Congratulations! Only one more Lab left.</p>

    </div></div></section>
<section id="submission"><button class="collapsible">Submission</button><div class="text-content"><div class="text-inner">

      <p>Please submit both python files that you have modified. Use the following command:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ense411/bin/submit Lab04 busterAgents.py inference.py
</code></pre></div>      </div>

      <p>You may check that you have submitted your assignment correctly by typing</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ense411/bin/submit -check
</code></pre></div>      </div>

      <p>And you can check the grades of your previous assignments by typing</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ense411/bin/submit -grade
</code></pre></div>      </div>
    </div></div></section>

    </main>

  </div>
  <footer>
    2022 Adam Tilson.
    <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/"
      >CC-BY-NC-SA</a
    >
  </footer>
  <button onclick="topFunction()" id="topButton" title="Go to top">â–² Top</button> 
  <script src="/assets/js/script.js"></script>

</body>
</html>
